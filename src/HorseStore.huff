
#define macro MAIN() = takes(0) returns(0) { 
    // Load function selector from calldata
    0x00 calldataload   
    0xE0 shr            // Extract first 4 bytes

    // if f_sector == updateHorseNumber == 0xcdfead2e
    // if f_sector == readHorseNumber == 0xe026c017

    0xcdfead2e
    eq

    updateJump
    jumpi

//     üîç Step-by-Step Execution Flow
// huff
// Copy
// Edit
// 0xcdfead2e  // Expected function selector (updateHorseNumber)
// eq          // Compares it with extracted function selector
// updateJump  // Target label for the jump
// jumpi  

     // Jump if the comparison is true
// 1Ô∏è‚É£ Function selector is compared (eq).

// If it matches, stack has 1 (true).
// If it does not match, stack has 0 (false).
// 2Ô∏è‚É£ If the stack has 1, jumpi moves execution to updateJump.

// The code skips ahead to updateJump: even though it appears later in the contract!
// 3Ô∏è‚É£ Execution reaches updateJump: and runs SET_HorseNumber().

// If the selector does not match, jumpi is ignored, and execution continues normally.
// üîπ Example Analogy: Think of a Movie Script üé¨
// Imagine you're reading a movie script.

// At line 10, the script says:
// "If the villain enters, go to scene 50."
// Scene 50 is written later in the script, but when the villain enters, the movie jumps to that scene.
// The same happens here‚Äîexecution "jumps" forward in the code if the condition is met.

// üìå TL;DR
// ‚úÖ Even though updateJump: is written later, jumpi can still go there.
// ‚úÖ jumpi doesn‚Äôt move line by line‚Äîit moves execution to a predefined label.
// ‚úÖ The EVM builds a jump table before running the contract, so the position of updateJump: doesn‚Äôt matter.




    updateJump:
        SET_HorseNumber()
}

#define macro SET_HorseNumber() = takes(0) returns(0) {}
